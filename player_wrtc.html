<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ANE Audio Player (PCM over WS)</title>
</head>
<body>
  <button id="start">Start Audio</button>
  <pre id="log"></pre>

<script>
const SENSOR_ID = "d8:3a:dd:f7:1a:cc";  // DEBE coincidir con el sensor_id del server

const proto = (location.protocol === "https:") ? "wss" : "ws";
const WS_URL = `${proto}://${location.host}/ws/listen/${encodeURIComponent(SENSOR_ID)}`;

const logEl = document.getElementById("log");
const log = (s) => (logEl.textContent += s + "\n");

let audioCtx, ws;
let nextPlayTime = 0;
let started = false;

let sampleRate = 48000;
let queue = [];
const TARGET_BUFFER_FRAMES = 10; // 10 * 20ms = 200ms

let framesRx = 0;
let t0 = performance.now();

function pcmLEToFloat32(ab, offset, samples) {
  const dv = new DataView(ab, offset);
  const out = new Float32Array(samples);
  let acc = 0;
  for (let i = 0; i < samples; i++) {
    const v = dv.getInt16(i*2, true);
    const f = v / 32768.0;
    out[i] = f;
    acc += f*f;
  }
  return { out, rms: Math.sqrt(acc / samples) };
}

function scheduleFrame(float32pcm) {
  const buf = audioCtx.createBuffer(1, float32pcm.length, sampleRate);
  buf.copyToChannel(float32pcm, 0);

  const src = audioCtx.createBufferSource();
  src.buffer = buf;
  src.connect(audioCtx.destination);

  const now = audioCtx.currentTime;
  if (nextPlayTime < now) nextPlayTime = now + 0.05;
  src.start(nextPlayTime);
  nextPlayTime += buf.duration;
}

function pump() {
  if (!started) return;
  if (queue.length < TARGET_BUFFER_FRAMES) return;
  while (queue.length > 0) scheduleFrame(queue.shift());
}

document.getElementById("start").onclick = async () => {
  document.getElementById("start").disabled = true;

  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  await audioCtx.resume();
  log("[UI] AudioContext listo.");

  ws = new WebSocket(WS_URL);
  ws.binaryType = "arraybuffer";

  ws.onopen = () => log("[UI] WS conectado: " + WS_URL);
  ws.onclose = (e) => log("[UI] WS cerrado. code=" + e.code);
  ws.onerror = (e) => log("[UI] WS error (mira consola del navegador).");

  ws.onmessage = (ev) => {
    if (typeof ev.data === "string") {
      log("[UI] CFG: " + ev.data);
      try {
        const cfg = JSON.parse(ev.data);
        if (cfg.sample_rate) sampleRate = cfg.sample_rate;
      } catch {}
      started = true;
      return;
    }

    const ab = ev.data;
    const dv = new DataView(ab);

    // Header PCM: magic(4) seq(4) sample_rate(4) channels(2) samples(2) big-endian
    const magic = dv.getUint32(0, false);
    if (magic !== 0x41554430) return; // 'AUD0'

    const sr = dv.getUint32(8, false);
    const ns = dv.getUint16(14, false);
    if (sr) sampleRate = sr;

    const { out, rms } = pcmLEToFloat32(ab, 16, ns);
    queue.push(out);
    pump();

    framesRx++;
    const now = performance.now();
    if (now - t0 >= 1000) {
      log(`[UI] frames/s=${framesRx} queue=${queue.length} rms~${rms.toFixed(4)}`);
      framesRx = 0;
      t0 = now;
    }
  };

  setInterval(() => {
    if (ws && ws.readyState === 1) ws.send("ping");
  }, 5000);
};
</script>
</body>
</html>
